{
    "collab_server" : "",
    "contents" : "#' Weight Vectors of the Bi-unit Canonical Form\n#'\n#' \\code{cov2weight(S)} returns the numeric vector in which the diagonal\n#' elements of the matrix \\eqn{D} are arranged, where \\eqn{DSD} is the bi-unit\n#' canonical form of \\eqn{S}.\n#'\n#' @param S Covariance matrix, especially it is positive semi-definite.\n#' @param Dvec Numeric vector of initial values of iteration.\n#' @param nu Numeric vector of subjective importance. It determines the\n#'   importance of each of the variates.\n#' @param tol Numeric number of tolerance. If the minimum eigenvalue of \\code{S}\n#'   is less than \\code{tol}, \\code{S} is considered not to be positive\n#'   definite.\n#' @param force Logical: if force=FALSE, \\code{S} should be strictly positive\n#'   definite. Default: FALSE.\n#' @return Numeric vector of diagonal elements of \\eqn{D}, which appears in the\n#'   bi-unit canonical form \\eqn{DSD} of \\eqn{S}.\n#' @examples\n#' S = matrix(0, 5, 5)\n#' S[1,1] = 1\n#' for(j in 2:5) S[1,j] = S[j,1] = -0.5\n#' for(i in 2:5){\n#'   for(j in 2:5){\n#'     if(i == j) S[i,j] = 1\n#'     else S[i,j] = 0.5\n#'   }\n#' }\n#' weight=cov2weight(S)\n#' weight\n#' @export\ncov2weight = function(S, Dvec = rep(1, nrow(S)), nu = rep(1, nrow(S)), tol = 1e-06, force = FALSE){\n  mineig = min(eigen(S)$val)\n  if(mineig < tol){\n    if(!force) stop(\"S is not positive definite.\")\n    if(mineig < -tol) stop(\"S is not positive semi-definite.\")\n    if(cov.check(S)$status == 0) stop(\"ker(S) has a non-negative vector.\")\n  }\n  if(any(nu<=0)){\n    stop(\"nu is not positive.\")\n  }\n  nms = rownames(S)\n  E = sqrt(diag(S))\n  S = diag(1/E) %*% S %*% diag(1/E)\n  p = nrow(S)\n  ep = Inf\n  while(ep > tol){\n    D2 = Dvec\n    for(i in 1:p){ # coordinate descent\n      b = sum(S[i,-i]*D2[-i])\n      r = sqrt(b^2 + 4*S[i,i]*nu[i])\n      D2[i] = ifelse(b>0, 2*S[i,i]*nu[i]/(b+r), (-b+r)/2/S[i,i])\n    }\n    ep = max(abs(D2 - Dvec))\n    Dvec = D2\n  }\n  Dvec = Dvec / E\n  names(Dvec) = nms\n  Dvec\n}\n\n#' Bi-unit Canonical Form\n#'\n#' \\code{cov2biu(S)} returns the bi-unit canonical form of \\code{S}.\n#'\n#' @param S Covariance matrix, especially it is positive semi-definite.\n#' @param nu Numeric vector of subjective importance. It determines the\n#'   importance of each of the variates.\n#' @param force Logical: if force=FALSE, \\code{S} should be strictly positive\n#'   definite. Default: FALSE.\n#' @param detail Logical: if detail=TRUE, it returns the list of the bi-unit\n#'   form and the weight vectors. Default: FALSE.\n#' @return Numeric matrix of the bi-unit canonical form \\eqn{DSD} of \\eqn{S}.\n#' @examples\n#' S = matrix(0, 5, 5)\n#' S[1,1] = 1\n#' for(j in 2:5) S[1,j] = S[j,1] = -0.5\n#' for(i in 2:5){\n#'   for(j in 2:5){\n#'     if(i == j) S[i,j] = 1\n#'     else S[i,j] = 0.5\n#'   }\n#' }\n#' B=cov2biu(S)\n#' B\n#' @export\ncov2biu = function(S, nu = rep(1, nrow(S)), force = FALSE, detail=FALSE){ # covariance matrix to bi-unit matrix\n  w = cov2weight(S, nu=nu, force=force)\n  B = diag(w) %*% S %*% diag(w)\n  dimnames(B) = dimnames(S)\n  if(detail) return(list(B=B, weight=w))\n  B\n}\n\n#' Objective General Index\n#'\n#' \\code{ogi(X)} returns the objective general index (OGI) of the covariance\n#' matrix \\code{S} of \\code{X}.\n#'\n#' Consider a data matrix of \\eqn{n} individuals with \\eqn{p} variates. The\n#' objective general index (OGI) is a general index that combines the \\eqn{p}\n#' variates into a univariate index in order to rank the \\eqn{n} individuals.\n#' The OGI is always positively correlated with each of the variates. For more\n#' details, see the references.\n#'\n#' @param X Numeric or ordered matrix.\n#' @param se Logical: if se=TRUE, it additionally computes \\code{w.se} and\n#'   \\code{v.se} by bootstrap. Default: FALSE.\n#' @param force Logical: if force=FALSE, \\code{S} should be strictly positive\n#'   definite. Default: FALSE.\n#' @param se.loop Iteration number in bootstrap for computation of standard\n#'   error.\n#' @param nu Numeric vector of subjective importance. It determines the\n#'   importance of each column of \\code{X}.\n#' @param center Logical: if center=TRUE, \\code{ogi(X)$Z} is centered.\n#'   Default:TRUE.\n#' @param mar Logical: if mar=TRUE, each of ordered categorical variates of\n#'   \\code{X} (if exists) is marginally converted into a numeric vector in\n#'   advance by the univariate OGI quantification. If mar=FALSE, the\n#'   simultaneous OGI quantification is applied. Default:FALSE.\n#' @return\n#' \\item{value}{The objective general index (OGI).}\n#' \\item{X}{The input matrix \\code{X}.}\n#' \\item{scaled}{The product of \\code{Z \\%*\\% diag(weight)}, where \\code{Z} and\n#'   \\code{weight} are as follows.}\n#' \\item{Z}{Numerical matrix converted from \\code{X}. If center = TRUE, it is centered.}\n#' \\item{weight}{The output of \\code{\\link{cov2weight}(S, nu=nu, force=force)},\n#'   where \\code{S} is the covariance matrix of \\code{X}. }\n#' \\item{rel.weight}{The product of \\code{weight * sqrt(diag(S))}, where \\code{S}\n#'   is the covariance matrix of \\code{X}.}\n#' \\item{biu}{The bi-unit canonical form of the covariance matrix of \\code{X}.}\n#' \\item{idx}{Numeric vector. If \\code{X} has ordered categorical variates,\n#'   \\code{idx} has (number of levels) -1 number of indexes.}\n#' \\item{w.se}{If requested, \\code{w.se} is numeric vector of the standard error\n#'   of \\code{weight}. It is calculated by bootstrap.}\n#' \\item{v.se}{If requested, \\code{v.se} is numeric vector of the standard error\n#'   of \\code{value}. It is calculated by bootstrap.}\n#' @references  Sei, T. (2016). An objective general index for multivariate\n#'   ordered data, Journal of Multivariate Analysis, 147, 247-264.\n#'   \\url{http://www.sciencedirect.com/science/article/pii/S0047259X16000269}\n#' @examples\n#' CT = matrix(c(\n#' 2,1,1,0,0,\n#' 8,3,3,0,0,\n#' 0,2,1,1,1,\n#' 0,0,0,1,1,\n#' 0,0,0,0,1), 5, 5, byrow=TRUE)\n#' X = matrix(0, 0, 2)\n#' for(i in 1:5){\n#'   for(j in 1:5){\n#'     if(CT[i,j]>0){\n#'       X = rbind(X, matrix(c(6-i,6-j), CT[i,j], 2, byrow=TRUE))\n#'     }\n#'   }\n#' }\n#' X0 = X\n#' X = as.data.frame(X0)\n#' X[,1] = factor(X0[,1], ordered=TRUE)\n#' X[,2] = factor(X0[,2], ordered=TRUE)\n#' ogiX = ogi(X)\n#' par(pty=\"s\", cex=1.7, mar=c(4.5,3,1,1))\n#' plot(ogiX$scaled, xlim=c(-3,3), ylim=c(-3,3), xlab=\"Geometry\", ylab=\"Probability\")\n#' for(t in 1:nrow(ogiX$scaled)){\n#'   xy = ogiX$scaled[t,]\n#'   g = rep(sum(xy)/2, 2)\n#'   segments(xy[1], xy[2], g[1], g[2], lty=2)\n#' }\n#' arrows(-3, -3, 3, 3)\n#' text(2.5, 2, \"OGI/2\")\n#' ogiX\n#'\n#'\n#' f = ordered(1:10)\n#' f[sample(1:10, 20, replace=TRUE)]\n#' Y = ogi(f)$value\n#' plot((1:10)/(10+1), Y, type=\"b\")\n#' xs = (1:1000)/1001\n#' points(xs, qnorm(xs), type=\"l\", col=\"red\")\n#'\n#'\n#' X = USJudgeRatings\n#' ogiX = ogi(X)\n#' nameX = ordered(names(X), names(X))\n#' plot(nameX, ogiX$weight, las=3, cex.axis=0.8, ylim=c(0,1.2), ylab=\"weight\")\n#' @export\nogi = function(X, se=FALSE, force=FALSE, se.loop=1000, nu=rep(1, ncol(X)), center=TRUE, mar=FALSE){ # The main function\n  if(!is.data.frame(X)) X = as.data.frame(X)\n  p = ncol(X)\n  if(mar){\n    for(i in 1:p){\n      if(is.ordered(X[,i]))\n        r = ogi(X[,i,drop=FALSE], force=force, mar=FALSE)\n      X[,i] = r$scaled[,1]\n    }\n  }\n  Z = ogi.numeric(X)\n  idx = attributes(Z)$index\n  nu.ori = nu\n  nu = rep(1, ncol(Z))\n  for(i in 1:p){\n    nu[idx==i] = nu.ori[i]/sum(idx==i)\n  }\n  Z = scale(Z, scale=FALSE, center=center)\n  if(center){\n    S = my.cov(Z)\n  }else{\n    S = t(Z) %*% Z / nrow(Z)\n  }\n  w = cov2weight(S, nu=nu, force=force)\n  rw = w * sqrt(diag(S))\n  Zw = Z %*% diag(w)\n  scaled = matrix(0, nrow(Z), p)\n  for(i in 1:p){\n    scaled[,i] = rowSums(Zw[,idx==i,drop=FALSE])\n  }\n  OGI = rowSums(scaled)\n  B = diag(w) %*% S %*% diag(w)\n  result = list(value = OGI, X = X, scaled = scaled, Z = Z, weight = w, rel.weight = rw, biu = B, idx = idx)\n\n  if(se){ # standard error by bootstrap\n    n = nrow(X)\n    wB = matrix(0, length(w), se.loop)\n    for(i in 1:se.loop){\n      ZB = Z[sample(1:n, n, replace=TRUE),]\n      ogiB = ogi(ZB, se=FALSE, force=TRUE)\n      wB[,i] = ogiB$weight\n    }\n    w.se = apply(wB, 1, stats::sd)\n    v.se = sqrt(Z^2 %*% w.se^2)\n    ymax = max(OGI + v.se); ymin = min(OGI - v.se)\n    graphics::plot(rowSums(my.scale(Z)), OGI, ylim=c(ymin,ymax), xlab=\"scaled sum\", ylab=\"OGI\")\n    #\t\ttext(rowSums(my.scale(Z)), OGI, 1:n)\n    graphics::segments(rowSums(my.scale(Z)), OGI-v.se, rowSums(my.scale(Z)), OGI+v.se)\n    result$w.se = w.se\n    result$v.se = v.se\n  }\n\n  result\n}\n\nogi.value = function(X){\n  ogi(X)$value\n}\n\nogi.scale = function(X){\n  ogi(X)$scaled\n}\n\nogi.weight = function(X){\n  ogi(X)$weight\n}\n\nogi.rel.weight = function(X){\n  ogi(X)$rel.weight\n}\n\nogi.biu = function(X){\n  ogi(X)$biu\n}\n\n# ToDo\n# predict.ogi = function(ogiX, Y){\n#   X = ogiX$X\n#   is.matrix(Y)\n# }\n\n# ToDo\n# table2factor = function(tb){\n#   if(!is.table(tb)) tb = as.table(tb)\n#   d = length(dim(tb))\n#   as.data.frame(tb)\n# }\n",
    "created" : 1513081686451.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1283483119",
    "id" : "C9EF3D99",
    "lastKnownWriteTime" : 1513672480,
    "last_content_update" : 1513672480008,
    "path" : "C:/OGI_package/OGI/R/ogi.R",
    "project_path" : "R/ogi.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}